<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safety Fundamentals in Complex Systems Engineering</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <div class="content-container">
        <header>
            <h1>Course Title: Safety Fundamentals in Complex Systems Engineering</h1>
            <div class="author-credits">
                <p>By Dr. John P. Thomas</p>
                <p>Massachusetts Institute of Technology (MIT)</p>
            </div>
        </header>

        <section id="section1">
            <h2>Section 1: Introduction to Safety</h2>
            
            <h3>A Broad View of Safety</h3>
            <p>In this class, we take a broad view of safety. An accident includes any undesirable loss—this could mean stakeholder losses like loss of life, mission failure, environmental damage, or the loss of critical protected information. This broad definition might be wider than you're used to, and the scope of safety can be customized to the types of losses your stakeholders care about. For instance, in the nuclear industry, safety might mean preventing damage to nuclear fuel rods, while in another field it could mean protecting confidential data or maintaining the integrity of a space mission.</p>
            
            <p>When we use terms like <em>hazardous</em> or <em>unsafe</em>, we are referring to conditions that lead to any form of stakeholder loss—not just loss of life. It is important to establish from the outset that our concern is with a wide spectrum of potential losses, depending on the context of the system and the values of the stakeholders involved.</p>
        </section>

        <section id="section2">
            <h2>Section 2: Understanding Defects in System Engineering</h2>
            
            <h3>The Timing of Defects</h3>
            <p>We face a major problem in engineering complex systems, which has been recognized for decades. The issue lies in when and where defects are introduced versus when they are detected. Approximately 70% of defects are introduced during the requirements and design phases. Only about 20% are introduced during the software coding or hardware detailed design phases. However, we tend to discover these defects much later, particularly during testing and integration phases.</p>
            
            <p>This delay causes significant cost increases. The cost difference between fixing a defect during testing versus requirements can be as high as 21 to 80 times more. In fact, some data suggests that the cost of catching a defect late can be up to four orders of magnitude higher. These are not hypothetical figures—they're based on real industry data.</p>
            
            <h3>Early Investment, Hidden Costs</h3>
            <p>NASA's 2015 data showed that although only 8% of project cost is spent during the concept phase, nearly 45% of the total cost is committed in that phase because of the long-term consequences of early decisions and assumptions. In essence, early-stage decisions lock in a significant portion of future costs.</p>
            
            <p>The Government Accountability Office (GAO) in the U.S. conducted a study of government-funded programs and found that the number one driver of cost and schedule overruns was inadequate systems engineering. Programs that suffered from these overruns had poor upfront investments in activities such as requirements analysis, concept analysis, and design processes.</p>
            
            <p>In this course, most examples and exercises will focus on the early stages of a project—concept, requirements, and early design—because that's where we have the greatest opportunity to influence outcomes at the lowest cost.</p>
        </section>

        <section id="section3">
            <h2>Section 3: Historical Perspectives on Safety</h2>
            
            <h3>The Evolution of Safety Models</h3>
            <p>System safety and systems engineering grew up separately. About a hundred years ago, the foundation of system safety was rooted in the idea that human error caused accidents. This perspective led to models like the Domino Model and eventually the Swiss Cheese Model (1980), all of which emphasized human error as the root cause.</p>
            
            <p>In the 1950s and 60s, analytical techniques such as Failure Modes and Effects Analysis (FMEA) and Fault Tree Analysis (FTA) were developed. These methods were particularly effective for mechanical and electromechanical systems of that era. Functional FMEA emerged as well, focusing not only on hardware but also on system functions.</p>
            
            <h3>The Software Era and the Gap</h3>
            <p>In the 1980s, a significant shift occurred—software began to control safety-critical systems. Despite this, safety methodologies didn't evolve in parallel. Most techniques still in use today are incremental updates of methods from the 50s and 60s. While they remain useful, they are ill-equipped to handle the complexities introduced by modern software-driven systems.</p>
            
            <p>Research has introduced alternatives, but few have gained wide industry adoption. One notable exception is Systems-Theoretic Process Analysis (STPA), which has been codified into standards and used widely across industries.</p>
        </section>

        <section id="section4">
            <h2>Section 4: Why STPA?</h2>
            
            <h3>Filling the Gaps</h3>
            <p>STPA was created to address new types of causes that older methods tend to miss. Unlike FMEA and fault trees, STPA focuses on system interactions, control structures, and process models. It helps identify unsafe control actions and emergent behaviors.</p>
            
            <p>This course is structured around this progression:</p>
            <ol>
                <li>We'll begin with traditional methods like FMEA and FTA, showing their strengths and critical limitations.</li>
                <li>Then we'll introduce STPA, showing how it fills those gaps.</li>
                <li>Finally, we'll discuss STPA's own limitations.</li>
            </ol>
            
            <p>The goal is not to declare STPA a silver bullet. Every method has limitations. What's critical is understanding when a method applies, when it doesn't, and what type of problem it's best suited to solve.</p>
            
            <h3>Pet Peeve: Ignoring Method Limitations</h3>
            <p>One problem in industry standards and training courses is that they rarely highlight method limitations. Engineers are taught how to follow the steps of a method, but not when <em>not</em> to use it. That's a gap this course aims to fill. We'll openly discuss the strengths and shortcomings of each approach.</p>
        </section>

        <section id="section5">
            <h2>Section 5: The Limits of Probability in Safety Analysis</h2>
            
            <h3>Probability Isn't a Universal Tool</h3>
            <p>A common misconception in safety is the overreliance on probability as a universal tool for risk assessment. While probability is useful in many scenarios—particularly when estimating hardware failure rates or known risks—it is inadequate for a wide range of system and human-centric errors.</p>
            
            <p>For example, what is the probability that a requirement in a system is incorrect? Or that a function has been completely missed? What about the probability that the design of a control algorithm is unsafe, even if it meets all documented requirements? These are not quantifiable in the same way hardware failures are.</p>
            
            <p>Industry standards often prohibit the use of probability to estimate software design flaws, human errors, or organizational failures because these are inherently unpredictable. Probabilistic analysis struggles with estimating risks that involve assumptions, architectural flaws, and missing requirements—exactly the types of errors that dominate modern safety incidents.</p>
            
            <h3>Misleading Assurance</h3>
            <p>Historically, systems have failed because flawed probabilistic reasoning gave a false sense of security. This leads to situations where designers calculate extremely low risks based on fault trees and numeric estimates but fail to account for interaction-level or assumption-level vulnerabilities.</p>
            
            <p>We will explore several real-world examples that reveal how probabilistic models can be off by multiple orders of magnitude—and how such errors contributed to catastrophic system failures.</p>
        </section>

        <section id="section6">
            <h2>Section 6: Categories of Losses — Failure vs. Interaction</h2>
            
            <h3>Component Failure Losses</h3>
            <p>Traditional safety techniques, especially those originating in the 1950s and 60s, are focused on <strong>component failure losses</strong>. These occur when a component does not perform according to its written requirements. The consensus across various industry standards, such as IEC 61508, is that a <strong>failure</strong> is when a component either stops providing a required function or behaves in a way that contradicts its specifications.</p>
            
            <p>Classic examples:</p>
            <ul>
                <li>A valve gets stuck in the open or closed position.</li>
                <li>A hydraulic line ruptures.</li>
                <li>A pump fails to operate.</li>
            </ul>
            
            <p>All of these result from a deviation from written requirements, and they're the foundation for reliability engineering. Solutions usually involve redundancy (multiple valves or pumps), preventive maintenance, or fail-safe design (e.g., a spring-loaded valve that fails open).</p>
            
            <h3>Component Interaction Losses</h3>
            <p>Modern safety must also address <strong>component interaction losses</strong>—situations where all components operate as designed, yet the system produces unsafe behavior due to unanticipated interactions.</p>
            
            <p>This shift began to be recognized in the 2000s, giving rise to what's now called the <strong>new view</strong> of system safety:</p>
            <ul>
                <li><strong>Old view</strong>: Accidents stem from failures.</li>
                <li><strong>New view</strong>: Accidents can also stem from <em>uncontrolled interactions</em> between correctly functioning components.</li>
            </ul>
            
            <p>These are often emergent behaviors not explicitly specified anywhere. They occur because of flawed assumptions, incomplete requirements, or overlooked dependencies between software, hardware, and human actions.</p>
        </section>

        <section id="section7" class="case-study">
            <h2>Section 7: Case Study — Mars Polar Lander</h2>
            
            <h3>The Setup</h3>
            <p>The Mars Polar Lander was an unmanned spacecraft designed to land on the Martian surface. During its descent, the lander deployed a parachute to slow down in Mars' thin atmosphere. It then jettisoned a heat shield and deployed three landing legs equipped with vibration sensors—also known as touchdown sensors. These sensors were designed to detect when the spacecraft touched the Martian surface, signaling the computer to cut off the descent thrusters.</p>
            
            <h3>What Went Wrong</h3>
            <p>During descent, the sequence of events executed exactly as planned:</p>
            <ul>
                <li>The parachute deployed.</li>
                <li>The legs extended.</li>
                <li>The vibration sensors in each leg detected the mechanical impact of deployment.</li>
            </ul>
            
            <p>These sensors were doing their job correctly—they registered the vibration and sent a signal to the flight computer. The software, interpreting these simultaneous signals from all three legs, concluded that the lander had touched down on Mars. Following its programming, it immediately shut off the descent thrusters.</p>
            
            <p>But the lander hadn't touched down. It was still 40 meters in the air. With the thrusters disabled, it entered free fall and crashed onto the Martian surface at high speed. The $110 million mission was lost.</p>
            
            <h3>The Aftermath and Blame</h3>
            <p>Who was at fault? It's complicated:</p>
            <ul>
                <li>The software engineers said, "The software did exactly what it was told to do—disable thrusters upon touchdown."</li>
                <li>The hardware engineers said, "Our sensors worked perfectly—they detected vibration, just as designed."</li>
            </ul>
            
            <p>And they were both right. Every component operated correctly, in accordance with its written requirements.</p>
            
            <p>This was not a <strong>component failure</strong>.<br>
            This was an <strong>interaction failure</strong>.</p>
            
            <p>The engineers had focused extensively on failure modes. Thousands of potential hardware and software failures were analyzed. But no one had asked: <em>What if everything works as designed—but the system logic is flawed?</em> That question never made it into any fault tree, any FMEA, or any requirements review.</p>
            
            <h3>Emergent Behavior</h3>
            <p>The critical flaw here was in the <strong>interaction between correct behaviors</strong>. The landing leg sensors responded to a legitimate vibration (from leg deployment), but the system treated that vibration as a landing event. That interpretation occurred too early—when the spacecraft was still airborne.</p>
            
            <p>This highlights an important lesson:</p>
            <blockquote><strong>Emergent behavior</strong> can arise even when individual components behave correctly.</blockquote>
            
            <h3>Why Traditional Methods Missed It</h3>
            <p>Failure-based methods like FMEA and Fault Tree Analysis are excellent at identifying what might go wrong with a component. But they assume the system works as designed. They rarely consider what happens when components interact in unanticipated—but technically correct—ways.</p>
            
            <p>In this case:</p>
            <ul>
                <li>The software followed its flowchart perfectly.</li>
                <li>The hardware sensors did what they were specified to do.</li>
                <li>The system architecture didn't account for timing and context in the interpretation of signals.</li>
            </ul>
            
            <p>What failed was the <strong>system's model of the world</strong>—its belief that it was already on the surface of Mars.</p>
            
            <p>This is precisely the kind of hazard that <strong>STPA is designed to uncover.</strong></p>
        </section>

        <section id="section8" class="case-study">
            <h2>Section 8: Case Study — Hitomi Satellite</h2>
            
            <h3>The Setup</h3>
            <p>Hitomi was a Japanese X-ray astronomy satellite launched by JAXA in 2016. It was designed to observe high-energy phenomena like black holes and galaxy clusters, offering deep insights into the structure of the universe. The spacecraft carried extremely sensitive instruments and had an ambitious mission profile. Everything worked perfectly after launch, and early operations were promising.</p>
            
            <p>But then, just over a month into the mission, Hitomi suddenly went silent. Ground control lost contact. Within hours, telescopes tracking the spacecraft observed that it had broken into pieces. A $273 million mission was lost.</p>
            
            <h3>What Happened</h3>
            <p>The sequence of failure began with a faulty reading from one of the spacecraft's inertial reference units (IRUs). It falsely reported that the satellite was slowly rotating. This was not true—the spacecraft was stable. However, the onboard flight software responded by commanding the reaction wheels to counter the perceived spin.</p>
            
            <p>The spacecraft had multiple attitude sensors, including star trackers that could independently verify orientation by capturing images of the sky. These star trackers disagreed with the IRU and correctly reported that the satellite was not spinning. But the system had been configured to trust the IRUs more than the star trackers. The disagreement led to the star tracker data being disregarded.</p>
            
            <p>As the IRU continued to falsely indicate increasing rotation, the system kept spinning the reaction wheels faster to compensate. Eventually, the wheels hit their speed limits. At this point, the system triggered an automatic failover: it switched to thrusters to stabilize the spacecraft.</p>
            
            <p>This was a catastrophic misstep. Since the satellite wasn't rotating in the first place, the thruster burst imparted real spin to a previously stable spacecraft. It began to tumble uncontrollably. The spin caused structural elements like solar arrays and instruments to break off, leading to complete disintegration.</p>
            
            <h3>The Root Cause</h3>
            <p>Every component in the Hitomi satellite worked as designed:</p>
            <ul>
                <li>The IRU measured rotation based on its internal sensors.</li>
                <li>The star trackers performed their task correctly.</li>
                <li>The software faithfully executed its logic.</li>
                <li>The thrusters fired in response to reaching wheel speed limits.</li>
            </ul>
            
            <p>The issue was a classic interaction failure:</p>
            <ul>
                <li>There was no check for sensor disagreement resolution.</li>
                <li>The software didn't have a model of faulty sensor behavior.</li>
                <li>Recovery logic didn't account for false positives from IRUs.</li>
            </ul>
            
            <h3>The Key Lesson</h3>
            <p>This was not a hardware malfunction. It was a failure in the system's control logic and trust architecture. The satellite trusted the wrong data, and when components followed through with their responses, the system spiraled into destruction.</p>
            
            <p>A systems-level safety analysis method like STPA could have identified the unsafe control actions that led to this outcome:</p>
            <ul>
                <li>Unsafe reliance on a single sensor without validation.</li>
                <li>No safe mode for resolving conflicts between sensor data.</li>
                <li>Aggressive recovery maneuvers that lacked contextual checks.</li>
            </ul>
        </section>

        <section id="section9" class="case-study">
            <h2>Section 8: Case Study — Uber Self-Driving Car</h2>
            
            <h3>The Setup</h3>
            <p>On March 18, 2018, an autonomous vehicle operated by Uber struck and killed a pedestrian in Tempe, Arizona. This was the first known fatality involving a self-driving car and a pedestrian.</p>
            
            <p>The vehicle involved was a modified Volvo XC90 SUV equipped with Uber's experimental autonomous driving system. Although the car had a safety driver sitting behind the wheel, the vehicle was in full autonomous mode at the time of the crash.</p>
            
            <h3>The Victim and the Context</h3>
            <p>The victim, a woman named Elaine Herzberg, was walking her bicycle across a darkened stretch of road at night. There was no crosswalk at that location. The road was wide, visibility was poor, and she emerged from the shadows into the vehicle's path.</p>
            
            <p>The self-driving system had nearly 6 seconds to react.</p>
            
            <h3>The Perception Stack</h3>
            <p>Uber's software stack had a complex system for perception and tracking. The system worked roughly like this:</p>
            <ol>
                <li>The car would detect an object using LIDAR and radar.</li>
                <li>It would then attempt to classify the object: pedestrian? vehicle? bicycle?</li>
                <li>It would then predict what the object would do next: continue crossing? stop? turn around?</li>
                <li>Based on this, it would decide whether to slow down, stop, or continue.</li>
            </ol>
            
            <p>In Herzberg's case, the system detected her. Repeatedly. But over the span of several seconds, it kept changing its classification:</p>
            <ul>
                <li>First, it tagged her as an unknown object.</li>
                <li>Then a vehicle.</li>
                <li>Then a bicycle.</li>
                <li>Then back to unknown.</li>
            </ul>
            
            <p>Each classification had different default behavioral predictions. For instance:</p>
            <ul>
                <li>If it's a car, it might assume the object will stay in its lane.</li>
                <li>If it's a pedestrian, it might expect erratic motion.</li>
                <li>If it's a cyclist, it might expect moderate, forward movement.</li>
            </ul>
            
            <p>Because the classification kept changing, the predicted behavior of the object also changed constantly.</p>
            
            <h3>No Consistent Prediction = No Action</h3>
            <p>Crucially, Uber's software stack did not maintain state continuity. Every cycle, it restarted the object classification and prediction process from scratch. This meant that the object's identity and behavior were being reinterpreted every 100 milliseconds or so. As a result:</p>
            <ul>
                <li>There was no long-term tracking of the object's path.</li>
                <li>The predictions didn't accumulate or stabilize.</li>
                <li>The system never gained enough confidence in the object's path to trigger braking.</li>
            </ul>
            
            <h3>The Tragic Outcome</h3>
            <p>Only 1.2 seconds before impact, the system finally recognized that the object was a pedestrian and that a collision was imminent. But by design, it was too late.</p>
            
            <p>The emergency braking system built into the Volvo was disabled during autonomous operation to avoid conflicting with Uber's own braking software. And Uber's own software had a built-in delay in taking emergency actions—partly to reduce false positives.</p>
            
            <p>The system never activated the brakes.</p>
            
            <p>The car struck Herzberg at approximately 40 mph. She died from her injuries.</p>
            
            <h3>The Root Causes</h3>
            <p>This was not a failure of perception hardware:</p>
            <ul>
                <li>The LIDAR and radar systems detected Herzberg.</li>
                <li>The cameras were operational.</li>
                <li>The onboard software was running.</li>
            </ul>
            
            <p>Instead, this was a failure of perception logic and interaction assumptions.</p>
            
            <p>Key design flaws included:</p>
            <ul>
                <li>No persistence in object tracking.</li>
                <li>Classification switching with no temporal memory.</li>
                <li>Braking disabled unless the system was highly confident.</li>
            </ul>
            
            <p>This was yet another case where components worked individually, but the interactions between subsystems failed to deliver safety.</p>
            
            <h3>Lessons Learned</h3>
            <ul>
                <li>Temporal coherence matters: You must track objects over time, not reset every frame.</li>
                <li>Classification confidence should not delay braking: It is better to brake unnecessarily than to hesitate fatally.</li>
                <li>Safety systems should default to conservatism: The system should assume unknown objects may enter the path, especially at night.</li>
            </ul>
            
            <p>This is a textbook example of system-level failure due to interaction complexity and flawed assumptions, not component malfunction.</p>
        </section>

        <section id="section10" class="case-study">
            <h2>Section 9: Case Study — Boeing 787 Battery Fires</h2>
            
            <h3>The Setup</h3>
            <p>The Boeing 787 Dreamliner was a revolutionary aircraft in many ways. It was Boeing's most advanced passenger airplane at the time, featuring cutting-edge composite materials, improved fuel efficiency, and state-of-the-art avionics. But one of its boldest design decisions was the use of lithium-ion batteries—the same type used in laptops and smartphones—to provide electrical power for many onboard systems.</p>
            
            <p>This decision was driven by the need for weight reduction and improved power efficiency. However, lithium-ion batteries come with well-known risks: if overcharged, overheated, or physically damaged, they can catch fire or explode.</p>
            
            <p>To mitigate this, Boeing built multiple layers of redundancy and protection around the battery system. They installed fire-resistant boxes, implemented smoke sensors, and engineered software logic to monitor and shut down systems under abnormal conditions.</p>
            
            <p>Despite these precautions, two serious battery fires occurred within months of the aircraft entering service, leading to the grounding of the entire 787 fleet worldwide in January 2013.</p>
            
            <h3>The First Incident</h3>
            <p>On January 7, 2013, a Japan Airlines 787 was parked at the gate at Boston Logan International Airport. With no passengers onboard, the auxiliary power unit (APU) was running to keep systems operational. Then, unexpectedly, smoke was seen coming from the battery compartment.</p>
            
            <p>Firefighters were called. When they opened the battery enclosure, they discovered thermal runaway—a battery cell had overheated, caught fire, and triggered adjacent cells to ignite. It took hours to fully cool the compartment.</p>
            
            <p>Luckily, no one was injured. But it raised alarm bells.</p>
            
            <h3>The Second Incident</h3>
            <p>Just over a week later, an All Nippon Airways (ANA) 787 had to make an emergency landing in Japan when pilots received warnings about battery problems and detected a burning smell in the cockpit. Passengers were evacuated, and once again, thermal runaway in the battery system was the cause.</p>
            
            <p>This second event confirmed that the first fire wasn't an isolated manufacturing defect. Something systemic was wrong.</p>
            
            <h3>Investigation and Findings</h3>
            <p>The NTSB (National Transportation Safety Board) launched an investigation. They examined battery enclosures, circuit boards, fire containment systems, and logs of system behavior.</p>
            
            <p>What they found was not a single failed component—but a collection of interacting design assumptions that failed under real-world conditions.</p>
            
            <p>Key findings included:</p>
            <ul>
                <li>The smoke detection system worked, but in one case, the power management software shut down the fans that were supposed to vent the smoke.</li>
                <li>The battery was operating within specified voltages, yet an internal short still occurred due to a manufacturing defect in one cell.</li>
                <li>The design assumed failures would be isolated, but thermal runaway cascaded across cells.</li>
                <li>The fire containment enclosure couldn't fully stop heat propagation or prevent smoke leakage into the electronics bay.</li>
            </ul>
            
            <p>So once again:</p>
            <ul>
                <li>All components met their documented requirements.</li>
                <li>The interactions and assumptions between components led to uncontrolled failure.</li>
            </ul>
            
            <h3>Emergent Behavior at Work</h3>
            <p>This wasn't just a battery issue—it was a system-level issue:</p>
            <ul>
                <li>The environmental control system relied on signals from smoke sensors—but had no override to keep the fans running in the presence of smoke.</li>
                <li>The assumption that only one cell could fail at a time turned out to be incorrect.</li>
                <li>Multiple software and hardware subsystems each acted rationally, but their combined effect failed to stop a dangerous situation.</li>
            </ul>
            
            <p>The 787 battery fires provide a clear example of modern aerospace systems operating in tightly coupled, highly interactive environments—where failure often comes not from a broken part, but from broken assumptions about how parts behave together.</p>
            
            <h3>The System Safety Lesson</h3>
            <p>These incidents forced Boeing to redesign the battery enclosure, add stronger fire containment, modify software behavior, and review all power management assumptions. It was a sobering reminder that:</p>
            
            <blockquote>"Safe components do not guarantee a safe system."</blockquote>
            
            <p>This incident emphasizes the value of methods like STPA, which explicitly examine unsafe control actions and flawed mental models—not just component reliability.</p>
        </section>

        <section id="section11">
            <h2>Section 10: The Control Loop Framework</h2>
            
            <h3>Why We Need a New Mental Model</h3>
            <p>As we've seen from previous case studies—Mars Polar Lander, Hitomi, Uber's autonomous vehicle, and the 787 battery fires—failures today often stem from correctly working components interacting in unsafe ways.</p>
            
            <p>To understand and prevent these kinds of losses, we need a model that allows us to:</p>
            <ol>
                <li>Analyze system-level behavior rather than just component failures.</li>
                <li>Understand how control decisions are made.</li>
                <li>Identify where incorrect beliefs about the system state can lead to unsafe actions.</li>
            </ol>
            
            <p>This is where the Control Loop Framework comes in—a foundational concept used by STPA.</p>
            
            <h3>The Anatomy of a Control Loop</h3>
            <p>At the core of any system involving decisions, commands, and actions lies a control loop. This framework is composed of the following elements:</p>
            <ol>
                <li><strong>Controller:</strong> The decision-making unit. This could be a person, a computer, or a hybrid (e.g., a pilot using an autopilot).</li>
                <li><strong>Control Actions:</strong> Commands issued to influence the system (e.g., enable thrusters, apply brakes, adjust throttle).</li>
                <li><strong>Actuators and Controlled Process:</strong> The part of the system being acted on (e.g., a vehicle, an engine, a robot arm).</li>
                <li><strong>Sensors and Feedback:</strong> These collect data from the environment or the process to inform the controller of the system's state.</li>
                <li><strong>Process Model:</strong> An internal representation (mental or software-based) that the controller uses to make decisions. This model can be outdated, incorrect, or incomplete.</li>
            </ol>
            
            <p>If a controller's process model is flawed, it may make decisions that are entirely reasonable—given the model—but completely unsafe in reality.</p>
            
            <h3>Example: Mars Polar Lander Revisited</h3>
            <p>Let's revisit the Mars Polar Lander through the lens of a control loop:</p>
            <ul>
                <li><strong>Controller:</strong> Onboard software.</li>
                <li><strong>Control Action:</strong> Disable descent thrusters upon touchdown.</li>
                <li><strong>Process Model:</strong> Belief that "if all three sensors report a jolt, the lander must be on the ground."</li>
                <li><strong>Sensor Input:</strong> Signals from leg-mounted accelerometers.</li>
                <li><strong>Reality:</strong> The jolt was due to leg deployment, not landing.</li>
            </ul>
            
            <p>The process model was incomplete. It failed to distinguish between a vibration due to landing gear deployment and an actual surface landing.</p>
            
            <h3>What Makes Control Unsafe?</h3>
            <p>STPA focuses on identifying Unsafe Control Actions (UCAs)—cases where a control command:</p>
            <ul>
                <li>Is provided when it should not be.</li>
                <li>Is not provided when it should be.</li>
                <li>Is applied at the wrong time or in the wrong order.</li>
                <li>Is stopped too early or sustained too long.</li>
            </ul>
            
            <p>These unsafe actions often arise not because of bad code or hardware failure, but because of incorrect assumptions within the controller's process model.</p>
            
            <h3>Control Loops in Human-Machine Teams</h3>
            <p>The framework is not limited to software systems. In fact, it works especially well for human-machine interactions.</p>
            
            <p>Take an air traffic controller:</p>
            <ul>
                <li>They receive radar feedback (sensor input).</li>
                <li>Their process model includes aircraft location, weather, and flight rules.</li>
                <li>They issue control actions like "descend to 5,000 feet."</li>
                <li>Pilots execute the action, completing the loop.</li>
            </ul>
            
            <p>If the controller misinterprets radar signals (e.g., due to signal lag), they may issue a command that leads to a near miss or collision—even though their actions were reasonable based on their belief.</p>
            
            <h3>Common Control Loop Failures</h3>
            <p>Across systems, common sources of unsafe control include:</p>
            <ul>
                <li>Delayed feedback (the system changes before feedback arrives).</li>
                <li>Overtrust in automation (controller stops validating sensor data).</li>
                <li>Noisy or missing sensor input.</li>
                <li>Controller logic errors (e.g., logical oversights in software).</li>
                <li>Conflicting models (human controller and automation disagree).</li>
            </ul>
            
            <p>All of these are prime targets for analysis within STPA.</p>
            
            <h3>Why This Matters</h3>
            <p>Most traditional safety tools focus on what might fail. Control loop modeling focuses on why correct actions in context may still lead to loss.</p>
            
            <p>It gives us the vocabulary to talk about:</p>
            <ul>
                <li>Perception errors</li>
                <li>Miscommunication</li>
                <li>Faulty logic</li>
                <li>Ambiguous procedures</li>
                <li>Delayed responses</li>
            </ul>
            
            <p>… all of which are now primary contributors to modern accidents.</p>
        </section>

        <section id="section12">
            <h2>Section 11: Control Loop Diagram</h2>
            
            <h3>Interactive Control Loop Visualization</h3>
            <p>Below is an interactive diagram editor that shows the control loop framework discussed in the previous section:</p>
            
            <div class="diagram-container">
                <iframe id="diagramFrame" src="https://embed.diagrams.net/?embed=1&proto=json&spin=1&saveAndExit=0&noSaveBtn=1&noExitBtn=1" 
                        frameborder="0" width="100%" height="500px"></iframe>
            </div>
            
            <script>
                // Basic STPA control loop template
                const stpaXML = '<mxGraphModel dx="1167" dy="665" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100"><root><mxCell id="0"/><mxCell id="1" parent="0"/><mxCell id="2" value="Controller" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1"><mxGeometry x="180" y="230" width="330" height="160" as="geometry"/></mxCell><mxCell id="3" value="Controlled Process" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1"><mxGeometry x="180" y="530" width="330" height="160" as="geometry"/></mxCell><mxCell id="4" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="2" target="3"><mxGeometry width="50" height="50" relative="1" as="geometry"><mxPoint x="250" y="390" as="sourcePoint"/><mxPoint x="250" y="530" as="targetPoint"/><Array as="points"/></mxGeometry></mxCell><mxCell id="5" value="Control Action" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" vertex="1" connectable="0" parent="4"><mxGeometry x="-0.4585" y="2" relative="1" as="geometry"><mxPoint as="offset"/></mxGeometry></mxCell><mxCell id="6" value="" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;rounded=0;exitX=0.7;exitY=0;exitDx=0;exitDy=0;entryX=0.7;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" source="3" target="2"><mxGeometry width="100" relative="1" as="geometry"><mxPoint x="380" y="450" as="sourcePoint"/><mxPoint x="480" y="450" as="targetPoint"/><Array as="points"/></mxGeometry></mxCell><mxCell id="7" value="Feedback" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" vertex="1" connectable="0" parent="6"><mxGeometry x="0.1546" y="2" relative="1" as="geometry"><mxPoint as="offset"/></mxGeometry></mxCell></root></mxGraphModel>';
                
                // Handle messages from the iframe
                window.addEventListener('message', function(e) {
                    if (e.origin.includes('diagrams.net')) {
                        try {
                            const msg = JSON.parse(e.data);
                            
                            // When the editor is initialized, load the diagram
                            if (msg.event === 'init') {
                                const frame = document.getElementById('diagramFrame');
                                frame.contentWindow.postMessage(JSON.stringify({
                                    action: 'load',
                                    xml: stpaXML
                                }), '*');
                            }
                        } catch (e) {
                            // Not JSON data
                        }
                    }
                });
            </script>
        </section>
    </div>
    
    <script>
        // Reading progress bar
        window.onscroll = function() {
            let winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            let height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            let scrolled = (winScroll / height) * 100;
            document.getElementById("progressBar").style.width = scrolled + "%";
        };
    </script>
</body>
</html>

